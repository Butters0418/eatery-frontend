# Eatery 前端 - 店員角色開發計畫

本文件旨在規劃店員後台介面的開發任務。計畫被劃分為多個連續的階段，以確保一個結構化且高效的工作流程。

---

## 階段一：認證與核心設定

**目標：** 實作基礎的登入系統並保護僅限店員訪問的路由。

- [ ] **任務 1.1：建立店員登入頁面 UI**
  - 重用或修改 `src/features/auth/LoginPage.tsx`。
  - 包含 `account` (帳號) 和 `password` (密碼) 的輸入欄位。
  - 新增一個提交按鈕和用於顯示錯誤訊息的區域。

- [ ] **任務 1.2：實作登入 API 整合**
  - 在表單提交時，呼叫 `POST /api/login` 端點。
  - 成功登入後，處理並儲存 JWT token。
  - 登入失敗時，顯示相關的錯誤訊息 (例如：「帳號或密碼錯誤」)。

- [ ] **任務 1.3：認證狀態管理**
  - 使用 `src/stores/useAuthStore.ts` 來儲存使用者的認證狀態和 JWT token。
  - 將 token 持久化到 local storage 以維持登入狀態。

- [ ] **任務 1.4：實作路由保護**
  - 建立一個路由守衛 (route guard) 或高階組件 (wrapper component)。
  - 保護所有店員相關的頁面 (例如：`/staff/dashboard`)。
  - 將未經認證的使用者重定向到登入頁面。

- [ ] **任務 1.5：實作登出功能**
  - 在店員介面中建立一個登出按鈕。
  - 點擊後，從 store 和 local storage 中清除 token。
  - 將使用者重定向到登入頁面。

---

## 階段二：訂單總覽頁面

**目標：** 顯示所有訂單的綜合列表，讓店員能快速掌握當前狀況。

- [ ] **任務 2.1：建立店員儀表板頁面**
  - 在 `src/features/staff/StaffDashboard.tsx` 建立主要頁面組件。
  - 設定 `/staff/dashboard` 的路由。

- [ ] **任務 2.2：取得並顯示訂單**
  - 頁面載入時，呼叫 `GET /api/orders` 端點以取得所有訂單。
  - 建立一個 `OrderCard` 組件來顯示單一訂單的摘要 (訂單 ID、類型、總金額、狀態)。
  - 渲染 `OrderCard` 組件列表。

- [ ] **任務 2.3：實作訂單篩選功能**
  - 新增用於篩選的 UI 元件：
    - 日期選擇器
    - 訂單類型 (全部/內用/外帶)
    - 付款狀態 (全部/未付款/已付款)
  - 當篩選條件變更時，更新 API 呼叫以包含篩選參數。

- [ ] **任務 2.4：導航至訂單詳情**
  - 讓每個 `OrderCard` 都可以點擊，或新增一個「查看詳情」按鈕。
  - 點擊後，導航至訂單詳情頁 (例如：`/staff/orders/:id`)，並傳遞訂單 ID。

---

## 階段三：訂單詳情頁與核心操作

**目標：** 讓店員能夠管理單一訂單，包括更新項目狀態和處理付款。

- [ ] **任務 3.1：建立訂單詳情頁**
  - 在 `src/features/staff/OrderDetailPage.tsx` 建立頁面組件。
  - 使用 URL 中的訂單 ID，呼叫 `GET /api/orders/:id` 來取得詳細的訂單資料。

- [ ] **任務 3.2：顯示詳細訂單資訊**
  - 渲染所有訂單細節：訂單資訊、時間軸和項目列表。
  - 對於每個項目，顯示其名稱、數量、加料和出餐狀態。

- [ ] **任務 3.3：實作「標記為已出餐」操作**
  - 在每個訂單項目旁新增一個切換開關或按鈕。
  - 狀態變更時，呼叫 `PATCH /api/orders/:id/item/:itemCode/served`。
  - 更新 UI 以反映新狀態。根據訂單狀態 (例如：已付款) 禁用此功能。

- [ ] **任務 3.4：實作「標記為已付款」操作**
  - 新增一個按鈕將整個訂單標記為已付款。
  - 點擊後，呼叫 `PATCH /api/orders/:id/paid`。
  - 更新 UI 並禁用後續的修改功能。

- [ ] **任務 3.5：實作「完成訂單」操作**
  - 新增一個按鈕來完成訂單。
  - 此按鈕只應在所有項目都已出餐且訂單已付款時啟用。
  - 點擊後，呼叫 `PATCH /api/orders/:id/complete`。

- [ ] **任務 3.6：(可選) 實作項目編輯/刪除**
  - 為尚未出餐的項目新增「編輯」和「刪除」按鈕。
  - 編輯時呼叫 `PATCH /api/orders/:id/item/:itemCode`。
  - 刪除時呼叫 `PATCH /api/orders/:id/item/:itemCode/delete`。

---

## 階段四：新增外帶訂單

**目標：** 允許店員直接從介面建立新的外帶訂單。

- [ ] **任務 4.1：建立「新增訂單」UI**
  - 可以是一個獨立的頁面 (`/staff/orders/new`) 或一個彈出對話框。
  - UI 應包含一個商品選擇區和一個購物車/摘要區。

- [ ] **任務 4.2：取得商品以供選擇**
  - 呼叫 `GET /api/products` 來取得可用的商品列表。
  - 顯示商品及其分類，並提供搜尋框以便快速選擇。

- [ ] **任務 4.3：實作本地購物車管理**
  - 使用狀態管理方案 (如 `useCartStore` 或本地 state) 來管理正在加入新訂單的項目。
  - 允許店員新增/移除項目及調整數量。

- [ ] **任務 4.4：實作訂單建立**
  - 點擊「提交訂單」時，根據 API 規格格式化購物車資料。
  - 呼叫 `POST /api/orders` 並帶上 `orderType: "外帶"`。
  - 成功後，重定向到訂單總覽頁或新建立的訂單詳情頁。

---

## 階段五：WebSocket 即時整合

**目標：** 透過即時更新來增強使用者體驗，例如新訂單和狀態變更的通知。

- [ ] **任務 5.1：建立 WebSocket 連線**
  - 店員登入後，初始化一個 WebSocket 連線。
  - 發送帶有 JWT token 的 `auth` 訊息以進行連線認證。

- [ ] **任務 5.2：處理傳入的通知**
  - 建立一個監聽器來處理來自 WebSocket 伺服器的訊息。
  - 實作解析不同事件類型 (`newOrder`, `newItem`, `orderUpdated` 等) 的邏輯。

- [ ] **任務 5.3：根據通知更新 UI**
  - **新訂單：** 顯示一個 toast/popup 通知。自動刷新訂單總覽頁的列表。
  - **新增項目：** 如果使用者正在查看對應的訂單詳情頁，則刷新項目列表。
  - **狀態變更：** 在總覽頁和詳情頁上即時更新狀態標籤和操作按鈕。